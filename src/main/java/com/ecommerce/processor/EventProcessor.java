package com.ecommerce.processor;

import com.ecommerce.events.*;
import com.ecommerce.order.Order;
import com.ecommerce.order.OrderStatus;
import com.ecommerce.observer.OrderEventManager;
import java.math.BigDecimal;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Processes events and updates Order states accordingly.
 * This code was generated by an LLM - hatchling
 */
public class EventProcessor {
    
    private static final Logger LOGGER = Logger.getLogger(EventProcessor.class.getName());
    private final Map<String, Order> orderStore = new ConcurrentHashMap<>();
    private final OrderEventManager eventManager;
    
    public EventProcessor(OrderEventManager eventManager) {
        this.eventManager = eventManager;
    }
    
    /**
     * Process an event and update the corresponding Order state.
     * 
     * @param event the event to process
     * @return the updated Order, or null if processing failed
     */
    public Order processEvent(Event event) {
        try {
            LOGGER.info("Processing event: " + event.getEventType() + " for order: " + event.getOrderId());
            
            switch (event.getEventType()) {
                case ORDER_CREATED:
                    return processOrderCreatedEvent((OrderCreatedEvent) event);
                case PAYMENT_RECEIVED:
                    return processPaymentReceivedEvent((PaymentReceivedEvent) event);
                case SHIPPING_SCHEDULED:
                    return processShippingScheduledEvent((ShippingScheduledEvent) event);
                case ORDER_CANCELLED:
                    return processOrderCancelledEvent((OrderCancelledEvent) event);
                case ORDER_SHIPPED:
                    return processOrderShippedEvent((OrderShippedEvent) event);
                case ORDER_DELIVERED:
                    return processOrderDeliveredEvent((OrderDeliveredEvent) event);
                default:
                    LOGGER.warning("Unknown event type: " + event.getEventType());
                    return null;
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error processing event: " + event.getEventType(), e);
            return null;
        }
    }
    
    private Order processOrderCreatedEvent(OrderCreatedEvent event) {
        Order order = new Order(
            event.getOrderId(),
            event.getCustomerId(),
            event.getItems(),
            event.getTotalAmount(),
            event.getShippingAddress()
        );
        
        // Store the order with the correct ID
        orderStore.put(event.getOrderId(), order);
        
        // Set initial status to CREATED
        updateOrderStatus(order, OrderStatus.CREATED);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        LOGGER.info("Created new order: " + order.getOrderId() + " with status: " + order.getStatus());
        return order;
    }
    
    private Order processPaymentReceivedEvent(PaymentReceivedEvent event) {
        Order order = orderStore.get(event.getOrderId());
        if (order == null) {
            LOGGER.warning("Order not found for payment event: " + event.getOrderId());
            return null;
        }
        
        BigDecimal paymentAmount = event.getAmount();
        BigDecimal orderTotal = order.getTotalAmount();
        
        OrderStatus newStatus;
        if (paymentAmount.compareTo(orderTotal) >= 0) {
            newStatus = OrderStatus.PAID;
            LOGGER.info("Full payment received for order: " + order.getOrderId());
        } else {
            newStatus = OrderStatus.PENDING_PAYMENT; // Keep as pending for partial payment
            LOGGER.info("Partial payment received for order: " + order.getOrderId() + 
                       " (paid: " + paymentAmount + ", total: " + orderTotal + ")");
        }
        
        // Update order with payment information
        order.setPaymentId(event.getPaymentId());
        updateOrderStatus(order, newStatus);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        return order;
    }
    
    private Order processShippingScheduledEvent(ShippingScheduledEvent event) {
        Order order = orderStore.get(event.getOrderId());
        if (order == null) {
            LOGGER.warning("Order not found for shipping event: " + event.getOrderId());
            return null;
        }
        
        // Update order with shipping information
        order.setShippingId(event.getShippingId());
        order.setTrackingNumber(event.getTrackingNumber());
        updateOrderStatus(order, OrderStatus.PROCESSING);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        LOGGER.info("Shipping scheduled for order: " + order.getOrderId());
        return order;
    }
    
    private Order processOrderCancelledEvent(OrderCancelledEvent event) {
        Order order = orderStore.get(event.getOrderId());
        if (order == null) {
            LOGGER.warning("Order not found for cancellation event: " + event.getOrderId());
            return null;
        }
        
        updateOrderStatus(order, OrderStatus.CANCELLED);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        LOGGER.info("Order cancelled: " + order.getOrderId() + " - Reason: " + event.getReason());
        return order;
    }
    
    private Order processOrderShippedEvent(OrderShippedEvent event) {
        Order order = orderStore.get(event.getOrderId());
        if (order == null) {
            LOGGER.warning("Order not found for shipped event: " + event.getOrderId());
            return null;
        }
        
        updateOrderStatus(order, OrderStatus.SHIPPED);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        LOGGER.info("Order shipped: " + order.getOrderId());
        return order;
    }
    
    private Order processOrderDeliveredEvent(OrderDeliveredEvent event) {
        Order order = orderStore.get(event.getOrderId());
        if (order == null) {
            LOGGER.warning("Order not found for delivered event: " + event.getOrderId());
            return null;
        }
        
        updateOrderStatus(order, OrderStatus.DELIVERED);
        
        // Notify observers
        eventManager.notifyObservers(order, event);
        
        LOGGER.info("Order delivered: " + order.getOrderId());
        return order;
    }
    
    private void updateOrderStatus(Order order, OrderStatus newStatus) {
        String oldStatus = order.getStatus().name();
        order.setStatus(newStatus);
        
        // Notify observers of status change
        eventManager.notifyStatusChange(order, oldStatus, newStatus.name());
    }
    
    /**
     * Get an order by ID.
     * 
     * @param orderId the order ID
     * @return the order, or null if not found
     */
    public Order getOrder(String orderId) {
        return orderStore.get(orderId);
    }
    
    /**
     * Get all orders in the store.
     * 
     * @return a copy of all orders
     */
    public Map<String, Order> getAllOrders() {
        return new ConcurrentHashMap<>(orderStore);
    }
    
    /**
     * Clear all orders from the store (useful for testing).
     */
    public void clearOrders() {
        orderStore.clear();
    }
}
